import UIKit

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//최댓값과 최솟값
//문제 설명
//문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 "(최소값) (최대값)"형태의 문자열을 반환하는 함수, solution을 완성하세요.
//예를들어 s가 "1 2 3 4"라면 "1 4"를 리턴하고, "-1 -2 -3 -4"라면 "-4 -1"을 리턴하면 됩니다.
//
//제한 조건
//s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.

//func solution(_ s:String) -> String {
//    let str = s.components(separatedBy: " ").compactMap { Int($0) }
//
//    return "\(str.min()!) \(str.max()!)"
//}
//
//solution("1 2 3 4")     // "1 4"
//solution("-1 -2 -3 -4") // "-4 -1"
//solution("-1 -1")     // ""-1 -1""

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//JadenCase 문자열 만들기
//문제 설명
//JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고)
//문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.
//
//제한 조건
//s는 길이 1 이상 200 이하인 문자열입니다.
//s는 알파벳과 숫자, 공백문자(" ")로 이루어져 있습니다.
//숫자는 단어의 첫 문자로만 나옵니다.
//숫자로만 이루어진 단어는 없습니다.
//공백문자가 연속해서 나올 수 있습니다.

//func solution(_ s:String) -> String {
//    var str = s.components(separatedBy: " ")
//    var answer = ""
//
//    for i in str {
//        for (index, char) in i.enumerated() {
//            if index == 0 {
//                answer += char.uppercased()
//            } else {
//                answer += char.lowercased()
//            }
//        }
//        answer += " "
//    }
//    answer.removeLast()
//
//    return answer
//}
//
//solution("3people unFollowed me")       // "3people Unfollowed Me"
//solution("for the last week")           // "For The Last Week"

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//올바른 괄호
//문제 설명
//괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어
//
//"()()" 또는 "(())()" 는 올바른 괄호입니다.
//")()(" 또는 "(()(" 는 올바르지 않은 괄호입니다.
//'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.
//
//제한사항
//문자열 s의 길이 : 100,000 이하의 자연수
//문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.

//func solution(_ s:String) -> Bool {
//    var stack = [Character]()
//
//    for char in s {
//        if char == "(" {
//            stack.append(char)
//        } else {
//            guard !stack.isEmpty else { return false }
//            stack.popLast()
//        }
//    }
//
//    return stack.isEmpty
//}
//
//solution("()()")       // true
//solution("(())()")     // true
//solution(")()(")       // false
//solution("(()(")       // false
    
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//최솟값 만들기
//문제 설명
//길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다.
//배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)
//
//예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면
//
//A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)
//A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)
//A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)
//즉, 이 경우가 최소가 되므로 29를 return 합니다.
//
//배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.
//
//제한사항
//배열 A, B의 크기 : 1,000 이하의 자연수
//배열 A, B의 원소의 크기 : 1,000 이하의 자연수

//func solution(_ A:[Int], _ B:[Int]) -> Int { zip(A.sorted(by: <), B.sorted(by: >)).reduce(0) { $0 + ($1.0 * $1.1)} }
//
//solution([1, 4, 2], [5, 4, 4])
//solution([1,2], [3,4])
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//이진 변환 반복하기
//문제 설명
//0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.
//
//x의 모든 0을 제거합니다.
//x의 길이를 c라고 하면, x를 "c를 2진법으로 표현한 문자열"로 바꿉니다.
//예를 들어, x = "0111010"이라면, x에 이진 변환을 가하면 x = "0111010" -> "1111" -> "100" 이 됩니다.
//
//0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 "1"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.
//
//제한사항
//s의 길이는 1 이상 150,000 이하입니다.
//s에는 '1'이 최소 하나 이상 포함되어 있습니다.

//func solution(_ s:String) -> [Int] {
//    var copy = s
//    var zeroCount: [Int] = []
//    var transCount = 0
//
//    while copy.count > 1 {
//        let count = copy.count
//
//        zeroCount.append(copy.filter { $0 == "0" }.count)
//        copy = String(count - zeroCount[transCount], radix: 2)
//        transCount += 1
//    }
//
//    return [transCount, zeroCount.reduce(0, +)]
//}
//
//solution("110010101001")        // [3,8]
//solution("01110")               // [3,3]
//solution("1111111")             // [4,1]
    
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//피보나치 수
//문제 설명
//피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.
//
//예를들어
//
//F(2) = F(0) + F(1) = 0 + 1 = 1
//F(3) = F(1) + F(2) = 1 + 1 = 2
//F(4) = F(2) + F(3) = 1 + 2 = 3
//F(5) = F(3) + F(4) = 2 + 3 = 5
//와 같이 이어집니다.
//
//2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.
//
//제한 사항
//n은 2 이상 100,000 이하인 자연수입니다.

//func solution(_ n:Int) -> Int {
//    var fibo: [Int] = [0, 1, 1]
//
//    for i in 3...n {
//        fibo.append((fibo[i - 1] + fibo[i - 2]) % 1234567)
//    }
//
//    return fibo[n]
//}

//struct matrix2x2 {
//    var _00, _01, _10, _11: Int
//
//    init(_00: Int, _01: Int, _10: Int, _11: Int) {
//        self._00 = _00 % 1234567
//        self._01 = _01 % 1234567
//        self._10 = _10 % 1234567
//        self._11 = _11 % 1234567
//    }
//
//    init(m: matrix2x2) {
//        self._00 = m._00 % 1234567
//        self._01 = m._01 % 1234567
//        self._10 = m._10 % 1234567
//        self._11 = m._11 % 1234567
//    }
//}
//
//func *(left: matrix2x2, right: matrix2x2) -> matrix2x2 {
//    return matrix2x2(_00: left._00 * right._00 + left._10 * right._01,
//                     _01: left._00 * right._10 + left._10 * right._11,
//                     _10: left._10 * right._00 + left._11 * right._01,
//                     _11: left._10 * right._10 + left._11 * right._11)
//}
//
//func solution(_ n:Int) -> Int {
//    var m = matrix2x2(_00: 1, _01: 0, _10: 0, _11: 1)
//    var fibo = matrix2x2(_00: 1, _01: 1, _10: 1, _11: 0)
//    var val = n
//
//    while val > 0 {
//        if val % 2 == 1 {
//            m = m * fibo
//        }
//
//        fibo = fibo * fibo
//        val /= 2
//    }
//
//    return m._01
//}

//func solution(_ n: Int) -> Int {
//    if n < 2 { return n }
//    var fibonacci = Array(repeating: 0, count: n+1)
//    fibonacci[0] = 0
//    fibonacci[1] = 1
//    for i in 2...n {
//        fibonacci[i] = (fibonacci[i-1] + fibonacci[i-2]) % 1234567
//    }
//    print(fibonacci)
//    return fibonacci[n]
//}

//solution(3)     // 2
//solution(5)     // 5
//solution(100000)
//solution(30)
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//다음 큰 숫자
//문제 설명
//자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.
//
//조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.
//조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.
//조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.
//예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.
//
//자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.
//
//제한 사항
//n은 1,000,000 이하의 자연수 입니다.

//func solution(_ n:Int) -> Int {
//    var binary = String(n, radix: 2)
//
//    if !binary.contains("0") {
//        binary.insert("0", at: binary.index(binary.startIndex, offsetBy: 1))
//    } else if binary.filter({ $0 == "1" }).count == 1 {
//        return Int(binary, radix: 2)! << 1
//    }
//
//    return Int(binary, radix: 2)!
//}

//func solution(_ n:Int) -> Int {
//    var binary = String(n, radix: 2)
//    var answer = 2
//    var count = 1
//    var oneCount = binary.filter { $0 == "1" }.count
//
//    while true {
//        if oneCount == String(n + count, radix: 2).filter({ $0 == "1"}).count {
//            answer = Int(String(n + count, radix: 2), radix: 2)!
//            break
//        } else {
//            count += 1
//        }
//    }
//
//    return answer
//}

//func solution(_ n:Int) -> Int {
//    var answer : Int = n + 1
//
//    while true {
//        print(n.nonzeroBitCount)
//        if n.nonzeroBitCount == answer.nonzeroBitCount { break }
//        answer += 1
//    }
//
//    return answer
//}
//
//solution(78) // 83
//solution(15) // 23
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//카펫
//문제 설명
//Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.
//
//Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.
//
//Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.
//
//제한사항
//갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
//노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
//카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.

//func solution(_ brown:Int, _ yellow:Int) -> [Int] {
//    let sum = brown + yellow
//    var tempArr: [Int] = []
//
//    let range = brown / yellow > yellow ? (yellow...(brown / yellow)): ((brown / yellow)...yellow)
//    for i in range {
//        if sum % i == 0 {
//            tempArr.append(i)
//        }
//    }
//
//    for i in tempArr {
//        if i != yellow {
//            print("한쪽 == \(sum / i), 다른쪽 == \(i)")
//        }
//    }
//
//    switch tempArr.count {
//    case 1: return [tempArr[0], tempArr[0]]
//    case 2: return [tempArr.max()!, tempArr.min()!]
//    default: return [1, 3]
//    }
//}
//
//solution(10, 2)         // [4, 3]
//solution(8, 1)          // [3, 3]
//solution(24, 24)        // [8, 6]
//solution(12, 3)           // [5, 3]
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//영어 끝말잇기
//문제 설명
//1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.
//
//1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
//마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
//앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
//이전에 등장했던 단어는 사용할 수 없습니다.
//한 글자인 단어는 인정되지 않습니다.
//다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.
//
//tank → kick → know → wheel → land → dream → mother → robot → tank
//
//위 끝말잇기는 다음과 같이 진행됩니다.
//
//1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.
//2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.
//3번 사람이 자신의 첫 번째 차례에 know를 말합니다.
//1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.
//(계속 진행)
//끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.
//
//사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.
//제한 사항
//끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.
//words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.
//단어의 길이는 2 이상 50 이하입니다.
//모든 단어는 알파벳 소문자로만 이루어져 있습니다.
//끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.
//정답은 [ 번호, 차례 ] 형태로 return 해주세요.
//만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.

//func solution(_ n:Int, _ words:[String]) -> [Int] {
//    var answer = [0, 0]
//    var duplicatedWord: [String: (indexs: [Int], count: Int)] = [:]
//    var tempStr: String = ""
//
//    words.enumerated().map {
//        var value = duplicatedWord[$0.element] ?? ([], 0)
//        value.indexs.append($0.offset)
//        duplicatedWord[$0.element] = (value.indexs, value.count + 1)
//    }
//
//    let dic = duplicatedWord.filter({ $0.value.count > 1 })
//    if dic.isEmpty {
//        for (index, word) in words.enumerated() {
//            if tempStr.isEmpty || tempStr.last == word.first {
//                tempStr.append(word)
//            } else if tempStr.last != word.first {
//                answer[0] = index % n + 1
//                answer[1] = index / n + 1
//                break
//            }
//        }
//    } else {
//        for i in dic {
//            answer[0] = (i.value.indexs[1] % n) + 1
//            answer[1] = ((i.value.indexs[1] / n) + 1)
//        }
//    }
//
//    return answer
//}
//
//solution(3, ["tank", "kick", "know", "wheel", "land", "dream", "mother", "robot", "tank"]) // [3,3]
//solution(5, ["hello", "observe", "effect", "take", "either", "recognize", "encourage", "ensure", "establish", "hang", "gather", "refer", "reference", "estimate", "executive"]) // [0,0]
//solution(2, ["hello", "one", "even", "never", "now", "world", "draw"]) // [1,3]
//solution(2, ["hello", "hello"])
    

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//짝지어 제거하기
//문제 설명
//짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.
//
//예를 들어, 문자열 S = baabaa 라면
//
//b aa baa → bb aa → aa →
//
//의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.
//
//제한사항
//문자열의 길이 : 1,000,000이하의 자연수
//문자열은 모두 소문자로 이루어져 있습니다.
//func solution(_ s:String) -> Int {
//    guard s.count % 2 == 0 else { return 0 }
//
//    var stack = ""
//
//    s.map {
//        if stack.last == $0 {
//            stack.popLast()
//        } else {
//            stack.append($0)
//        }
//    }
//
//    return stack.isEmpty ? 1: 0
//}
//
//solution("baabaa")  // 1
//solution("cdcd")    // 0
//solution("babbabbb")

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//N개의 최소공배수
//문제 설명
//두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.
//
//제한 사항
//arr은 길이 1이상, 15이하인 배열입니다.
//arr의 원소는 100 이하인 자연수입니다.

//func solution(_ arr:[Int]) -> Int {
//    var result = arr[0]
//
//    Array(arr.dropFirst()).map {
//        result = ($0 * result) / getGreatestCommonDivisor($0, result)
//    }
//
//    return result
//}
//
//func getGreatestCommonDivisor(_ m: Int, _ n: Int) -> Int {
//    var a = 0
//    var b = max(m, n)
//    var r = min(m, n)
//    while r != 0 {
//        a = b
//        b = r
//        r = a % b
//    }
//    return b
//}
//
//func gcd(_ a: Int, _ b: Int) -> Int {
//    let r = a % b
//    if r != 0 {
//        return gcd(b, r)
//    } else {
//        return b
//    }
//}
//
//func lcm(_ m: Int, _ n: Int) -> Int {
//  return m / gcd(m, n) * n
//}
//func solution(_ arr:[Int]) -> Int {
//    return arr.reduce(1) { lcm($0, $1) }
//}
//
//
//solution([2,6,8,14])        // 168
//solution([1,2,3])           // 6
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//예상 대진표
//문제 설명
//△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, ... , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다.
//
//이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다.
//
//제한사항
//N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.)
//A, B : N 이하인 자연수 (단, A ≠ B 입니다.)
//func solution(_ n:Int, _ a:Int, _ b:Int) -> Int {
//    var count = 1
//    var copyA = min(a, b),
//        copyB = max(a, b),
//        copyN = n
//
//    while true {
//        if (abs(copyA - copyB) <= 1) && (min(copyA, copyB) % 2 == 1) { break }
//        if (copyA == 1 || copyB == 1) && (copyB == 1 || copyB == 2) { break }
//        if copyN == 1 {
//            count -= 1
//            break
//        }
//
//        copyN = copyN >> 1
//        count += 1
//        copyA /= 2
//        copyB /= 2
//    }
//
//    return count
//}
//
//solution(8, 4, 7) // 3
//solution(4, 1, 2) // 1
//solution(16, 8, 9) // 2
//solution(4, 2, 3) // 2
//solution(8, 1, 8)
//solution(2, 1, 2)
//solution(4, 1, 4)
//solution(8, 1, 8)
//solution(16, 1, 16)
//solution(32, 1, 32)
//solution(64, 1, 64)
//solution(1048576, 1048574, 1048576)
//print(pow(2, 20))
//print( 1 / 2)
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//[1차] 캐시
//문제 설명
//캐시
//지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.
//이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.
//어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.
//
//어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.
//
//입력 형식
//캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.
//cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.
//cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.
//각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.

func solution(_ cacheSize:Int, _ cities:[String]) -> Int {
    guard cacheSize != 0 else { return cities.count * 5 }
    var queue: [String] = []
    var result = 0
    
    cities.map {
        if queue.contains($0.lowercased()) {
            queue.remove(at: queue.firstIndex(of: $0.lowercased())!)
            queue.append($0.lowercased())
            result += 1
        } else {
            if queue.count < cacheSize {
                queue.append($0.lowercased())
                result += 5
            } else {
                queue.removeFirst()
                queue.append($0.lowercased())
                result += 5
            }
        }
    }
    
    return result
}

solution(3, ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "Jeju", "Pangyo", "Seoul", "NewYork", "LA"])
solution(3, ["Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul"])
solution(2, ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"])
solution(5, ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"])
solution(2, ["Jeju", "Pangyo", "NewYork", "newyork"])
solution(0, ["Jeju", "Pangyo", "Seoul", "NewYork", "LA"])
//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
